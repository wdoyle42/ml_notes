---
title: "Regression: Feature Selection"
author: "Will Doyle"
---

## Introduction

```{r}
library(tidyverse)
library(tidymodels)
library(here)
```

## The Data

We'll again use the civil rights dataset. 


```{r}
cr<-read_csv(here("data", "crdc.csv"))  
```




## Feature Engineering

Feature engineering is crucial in Machine Learning for improving model performance. It involves transforming raw data into a format that is better suited for a model. Below, we select the in-school suspension rates (iss), student-related features, neighborhood characteristics, urbanicity, and region.

```{r}
cr<-cr %>%
  select(iss,
         contains("stu"), 
         contains("ngh"),
         urbanicity,
         region)
```
## Training and Testing

We'll split the data into training and testing, using the default 75/25 split. 

```{r}
split_data<-initial_split(cr)

cr_train<-training(split_data)

cr_test<-testing(split_data)
```

## OLS 

For the baseline example let's run OLS on the data

### Set workflow

`Tidymodels` relies on the idea of a modeling workflow. Let's start by defining an empty one. 

```{r}
cr_wf<-workflow()
```


### Model statement
Next we'll define a simple linear model via `lm`. 

```{r}
lm_fit<-
  linear_reg()%>%
  set_engine("lm")%>%
  set_mode("regression")
```


Then we can add the model to the workflow. 
```{r}
cr_wf<-cr_wf%>%
  add_model(lm_fit)
```

### Recipe

A recipe in tidymodels is the set of steps that need to be done to the data prior to analysis. The wonderful think about the recipe approach is that it works exactly the same on training and testing or resampled data. 

First we'll set a formula-- the one below says to create a model with log sale price on the LHS and everything else in the dataset on the RHS. 

```{r}
cr_formula<-as.formula("iss~.")
```

With that formula, we can then define the recipe. The recipe are the remaining feature engineering steps that need to occur. In this case we're going to define the dependent variable via `update_role`, then normalize the data via `step_normalize` then drop all missing data via `step_naomit.`

```{r}
cr_rec<-recipe(cr_formula,data=cr_train)%>%
  update_role(iss,new_role = "outcome")%>%
  step_other(all_nominal_predictors(),threshold = .01)%>%
  step_dummy(all_nominal_predictors())%>%
  step_filter_missing(all_predictors(),threshold = .1)%>%
  step_naomit(all_outcomes(),all_predictors())%>%
  step_zv(all_predictors())%>%
  step_corr(all_predictors(),threshold = .95)%>%
  step_normalize(all_predictors())
```


Now we can add the recipe to the workflow.

```{r}
cr_wf<-cr_wf%>%
  add_recipe(cr_rec)
```

## Fit the model to the training data

Quite easily done via `fit`

```{r}
cr_wf<-cr_wf%>%
  fit(cr_train)
```

## Predict results in the testing data

Now we can use the estimates in the fitted model  to predict outcomes in the testing dataset. These will be called `.pred` until we rename them as `.pred1`, and add them to the dataset.  

```{r}
  cr_test<-
  cr_wf%>%
  predict(new_data=cr_test)%>%
  rename(.pred1=.pred)%>%
  bind_cols(cr_test)
```

## Calculate RMSE

Next we can use the `rmse` command to compare the actual log sale price in the dataset to the predicted log price. 

```{r}
cr_test%>%
  rmse(truth=iss,estimate=.pred1)
```


## Lasso model


One of the key decisions for an analyst is which variables to include. We can make decisions about this using theory, or our understanding of the context, but we can also rely on computational approaches. This is known as *regularization* and it involves downweighting the importance of coefficients from a model based on the contribution that a predictor makes. We're going to make use of a regularization penalty known as the "lasso." The lasso downweights variables mostly be dropping variables that are highly correlated with one another, leaving only one of the correlated variables as contributors to the model. We set the degree to which this penalty will be implemented by setting the "penalty" variable in the model specification. (This is also called the L1 penalty, or L1 regularization)


Now we can update the model to use lasso, which will subset on a smaller number of covariates. In the `tidymodels` setup, ridge is alpha (mixture)=0, while lasso is alpha (mixture)=1.   https://parsnip.tidymodels.org/reference/glmnet-details.htm
```{r}
penalty_spec<-.1

mixture_spec<-1

lasso_fit<- 
  linear_reg(penalty=penalty_spec,
             mixture=mixture_spec) %>% 
  set_engine("glmnet")%>%
  set_mode("regression")
```

## Define the Workflow

```{r}
cr_wf<-workflow()
```

## Add the Model

```{r}
cr_wf<-cr_wf%>%
  add_model(lasso_fit)
```


Now we can add our recipe to the workflow. 

```{r}
cr_wf<-cr_wf%>%
  add_recipe(cr_rec)
```

Aad fit the data


```{r}
cr_wf<-cr_wf%>%
  fit(cr_train)
```

We can use the same set of commands as above to generate as prediction, which will be pred2 this time.

```{r}
  cr_test<-
  cr_wf%>%
  predict(new_data=cr_test)%>%
  rename(.pred2=.pred)%>%
  bind_cols(cr_test)
```

We can then check the rmse from our model. 
```{r}
cr_test%>%
  rmse(truth=iss,estimate=.pred2)

cr_test%>%
  rmse(truth=iss,estimate=.pred1)

```

We can also look at the coefficients to get a sense of what got included and what got dropped. 
```{r}
cr_wf%>%
  extract_fit_parsnip()%>%
  tidy()
```


## Cross Validation

The essence of prediction is discovering the extent to which our models can predict outcomes for data that does not come from our sample. Many times this process is temporal. We fit a model to data from one time period, then take predictors from a subsequent time period to come up with a prediction in the future. For instance, we might use data on team performance to predict the likely winners and losers for upcoming soccer games. 

This process does not have to be temporal. We can also have data that is out of sample because it hadn't yet been collected when our first data was collected, or we can also have data that is out of sample because we designated it as out of sample.

The data that is used to generate our predictions is known as 
*training* data. The idea is that this is the data used to train our model, to let it know what the relationship is between our predictors and our outcome. So far, we have worked mostly with training data. 

That data that is used to validate our predictions is known as *testing* data. With testing data, we take our trained model and see how good it is at predicting outcomes using out of sample data. 

One very simple approach to this would be to cut our data in half. This is what we've done so far.  We could then train our model on half the data, then test it on the other half. This would tell us whether our measure of model fit (e.g. rmse, auc) is similar or different when we apply our model to out of sample data. 

But this would only be a "one-shot" approach. It would be better to do this multiple times, cutting the data into two parts: training and testing, then fitting the model to the training data, and then checking its predictions against the testing data. That way, we could generate a large number of rmse's to see how well the model fits on lots of different possible out-of-sample predictions. 

This process is called *cross validation*, and it involves two important decisions: first, how will the data be cut, and how many times will the validation run. 

We're going to cut our training dataset 75/25, and we'll repeat that 25 times. This is so our code will run faster-- we would really want to do this more like 1,000 times in practice. 

## Monte Carlo Resampling

The code below will generate a resampled dataset using monte carlo resampling. 

```{r}
cr_rs<-mc_cv(cr_train,times=100) ## More like 1000 in practice
```


We can then fit the model to the resampled data via `fit_resamples`.
```{r}
cr_lasso_fit<-cr_wf%>%
  fit_resamples(cr_rs)
```

The model has now been fit to 25 versions of the training data. Let's look at the metrics using `collect_metrics`.
```{r}
cr_lasso_fit%>%collect_metrics()
```


We can also pull certain metrics like rmse one at a time if we want.
```{r}
cr_lasso_fit%>%
  unnest(.metrics)%>%
  filter(.metric=="rmse")%>%
  ggplot(aes(x=.estimate))+
  geom_density()
```


## Model Tuning

The problem with the above is that I arbitrarily set the value of penalty to be .1. Do I know this was correct? No!
What we need to do is try out a bunch of different values of the penalty, and see which one gives us the best model fit. This
process has the impressive name of "hyperparameter tuning" but it could just as easily be called "trying a bunch of stuff to see what works."

Below I'm going to give the argument `tune()` for the value of penalty. This will allow us to "fill in" values later. 


Of course we don't know what penalty to use in the lasso model, so we can tune it. This is set up
by using the `penalty=tune()` approach below. 

```{r}
cr_tune_model<- 
  linear_reg(penalty=tune(),mixture=mixture_spec)%>% 
  set_engine("glmnet")
```

Now that we've said which parameter to tune, we'll use the `grid_regular` command to get a set of nicely spaced out values. This command is specific to the parameter, so it will choose reasonable values for a penalty. 

```{r}
lasso_grid<-grid_regular(extract_parameter_set_dials(cr_tune_model) ,levels=10)
```

We can use `update_model` to change our workflow with the new model. 
```{r}
cr_wf<-cr_wf%>%
  update_model(cr_tune_model)
```

Then we can use `tune_grid` to run the model through the resampled data, using the grid supplied. 
```{r}
cr_lasso_tune_fit <- 
  cr_wf %>%
    tune_grid(cr_rs,grid=lasso_grid)
```

## Examine Results

Lets' take a look and see which models fit better. 

```{r}
cr_lasso_tune_fit%>%
  collect_metrics()%>%
  filter(.metric=="rmse")%>%
  arrange(mean)
```


## Ridge Regression

Ridge regression is another technique for regularization, which helps to solve the multicollinearity problem by adding a degree of bias to the regression estimates. It includes every predictor in the model but shrinks the coefficients of less important predictors towards zero, thus minimizing their impact on the model.

In the tidymodels setup, ridge is specified with alpha (mixture) = 0.

```{r}
mixture_spec<-0

cr_tune_model<- 
  linear_reg(penalty=tune(),mixture=mixture_spec)%>% 
  set_engine("glmnet")
```

```{r}
ridge_grid<-grid_regular(extract_parameter_set_dials(cr_tune_model) ,levels=10)
```

```{r}
cr_wf<-cr_wf%>%
  update_model(cr_tune_model)
```

```{r}
cr_ridge_tune_fit <- 
  cr_wf %>%
    tune_grid(cr_rs,grid=ridge_grid)
```



```{r}
cr_ridge_tune_fit%>%
  collect_metrics()%>%
  filter(.metric=="rmse")%>%
  arrange(mean)
```

```{r}
best_ridge_penalty<-

cr_ridge_result<-cr_wf%>%
  fit(cr_train)

cr_ridge_result%>%extract_fit_parsnip()%>%tidy()
```


## Elastic Net

The elastic net model combines the lasso and the ridge using the mixture parameter. Let's just go ahead and tune on that as well.

```{r}
cr_wf<-workflow()
```

```{r}
cr_tune_model<- 
  linear_reg(penalty=tune(),mixture=tune())%>% 
  set_engine("glmnet")
```

```{r}
enet_grid<-grid_regular(parameters(cr_tune_fit) ,levels=10)
```

We can use `add_model` to change our workflow with the new model. 
```{r}
cr_wf<-cr_wf%>%
  update_model(cr_tune_fit)
```


Then we can use `tune_grid` to run the model through the resampled data, using the grid supplied. 
```{r}
cr_enet_tune_fit <- 
  cr_wf %>%
    tune_grid(cr_rs,grid=enet_grid)
```

## Examine Results

Lets' take a look and see which models fit better. 

```{r}
cr_lasso_tune_fit%>%
  collect_metrics()%>%
  filter(.metric=="rmse")%>%
  arrange(mean)%>%
  print(n=100)

cr_lasso_tune_fit%>%show_best()
cr_lasso_tune_fit%>%select_best()
```


```{r}
cr_lasso_tune_fit%>%
  collect_metrics()%>%
  filter(.metric=="rmse")%>%
  arrange(mean)%>%
  print(n=100)

cr_ridge_tune_fit%>%show_best()
cr_ridge_tune_fit%>%select_best()
```

```{r}

```

